--- monit/src/sendmail.c.orig	2014-12-13 08:14:20.000000000 -0600
+++ monit/src/sendmail.c	2014-12-13 13:50:02.000000000 -0600
@@ -183,6 +183,56 @@
 }
 
 
+void spawn_system_cmd(const char *cmd);
+
+static FILE *temp_file(char *tmpname)
+{
+	FILE *p = NULL;
+	int fd;
+
+	if ((fd = mkstemp(tmpname)) > -1) {
+		fchmod(fd, S_IRUSR | S_IWUSR);
+		if ((p = fdopen(fd, "w+")) == NULL) {
+			close(fd);
+		}
+	}
+	return p;
+}
+
+
+static int sendmail_local(Mail_T mail) {
+	Mail_T m;
+	FILE *p;
+	const char *template = "/tmp/monitmail-XXXXXX";
+	const char *mailcmd = "/usr/sbin/sendmail -t";
+	char *tmpname = CALLOC(sizeof(char), strlen(template) + 1);
+	char *system_cmd = CALLOC(sizeof(char), STRLEN);
+	int failed = FALSE;
+
+	for (m = mail; m; m = m->next) {
+		strcpy(tmpname, template);
+		if ((p = temp_file(tmpname)) != NULL) {
+			fprintf(p, "From: %s\n", m->from);
+			if (m->replyto)
+				fprintf(p, "Reply-To: %s\n", m->replyto);
+			fprintf(p, "To: %s\n", m->to);
+			fprintf(p, "Subject: %s\n", m->subject);
+			fprintf(p, "\n");
+			fprintf(p, "%s\n", m->message);
+			fclose(p);
+			snprintf(system_cmd, STRLEN, "( %s < %s ; rm -f %s ) &", mailcmd, tmpname, tmpname);
+			spawn_system_cmd(system_cmd);
+		} else {
+                	failed = TRUE;
+                	LogError("Sendmail: Unable to launch '%s' (can't create temporary file)\n", mailcmd);
+		}
+	}
+
+	FREE(system_cmd);
+	FREE(tmpname);
+	return failed;
+}
+
 /* ------------------------------------------------------------------ Public */
 
 
@@ -199,6 +249,10 @@
 
         ASSERT(mail);
 
+	if (Run.mailservers && strcmp(Run.mailservers->host, "localhost") == 0) {
+        	return sendmail_local(mail);
+	}
+
         memset(&S, 0, sizeof(S));
         S.status_message = StringBuffer_create(STRLEN);
 
--- monit/src/spawn.c.orig	2014-12-13 12:50:23.000000000 -0600
+++ monit/src/spawn.c	2014-12-13 13:16:12.000000000 -0600
@@ -243,3 +243,88 @@
 
 }
 
+/**
+ * Execute the given command, like spawn() but for a single shell command
+ */
+void spawn_system_cmd(const char *cmd) {
+        pid_t pid;
+        sigset_t mask;
+        sigset_t save;
+        int stat_loc = 0;
+        int exit_status;
+
+        /*
+         * Block SIGCHLD
+         */
+        sigemptyset(&mask);
+        sigaddset(&mask, SIGCHLD);
+        pthread_sigmask(SIG_BLOCK, &mask, &save);
+
+        pid = fork();
+        if(pid < 0) {
+                LogError("Cannot fork a new process -- %s\n", STRERROR);
+                exit(1);
+        }
+
+        if(pid == 0) {
+
+                if(! Run.isdaemon) {
+                        for(int i = 0; i < 3; i++)
+                                if(close(i) == -1 || open("/dev/null", O_RDWR) != i)
+                                        stat_loc |= redirect_ERROR;
+                }
+
+                Util_closeFds();
+
+                setsid();
+
+                pid = fork();
+                if(pid < 0) {
+                        stat_loc |= fork_ERROR;
+                        _exit(stat_loc);
+                }
+
+                if(pid == 0) {
+                        /*
+                         * Reset all signals, so the spawned process is *not* created
+                         * with any inherited SIG_BLOCKs
+                         */
+                        sigemptyset(&mask);
+                        pthread_sigmask(SIG_SETMASK, &mask, NULL);
+                        signal(SIGINT, SIG_DFL);
+                        signal(SIGHUP, SIG_DFL);
+                        signal(SIGTERM, SIG_DFL);
+                        signal(SIGUSR1, SIG_DFL);
+                        signal(SIGPIPE, SIG_DFL);
+
+                        (void) execl("/bin/sh", "/bin/sh", "-c", cmd, (char *) NULL);
+                        _exit(errno);
+                }
+
+                /* Exit first child and return errors to parent */
+                _exit(stat_loc);
+        }
+
+        /* Wait for first child - aka second parent, to exit */
+        if(waitpid(pid, &stat_loc, 0) != pid) {
+                LogError("Waitpid error\n");
+        }
+
+        exit_status = WEXITSTATUS(stat_loc);
+        if (exit_status & fork_ERROR)
+                LogError("Cannot fork a new process for '%s'\n", cmd);
+        if (exit_status & redirect_ERROR)
+                LogError("Cannot redirect IO to /dev/null for '%s'\n", cmd);
+
+        /*
+         * Restore the signal mask
+         */
+        pthread_sigmask(SIG_SETMASK, &save, NULL);
+
+        /*
+         * We do not need to wait for the second child since we forked twice,
+         * the init system-process will wait for it. So we just return
+         */
+
+}
+
